---
title: "Docker コーディング規約 ベストプラクティス"
description: "Dockerのベストプラクティスについてまとめたよ！これを参考に、もっと効率的で安全なDockerイメージを作れるようになるはずだよ！🚀"
author: "Reco"
date: "2025-06-03"
tag: #Docker, #ベストプラクティス, #コンテナ, #Dockerfile, #CI/CD
globs: *
---

# Docker コーディング規約のベストプラクティス ✨

Jun、Dockerのベストプラクティスについてまとめたよ！これを参考に、もっと効率的で安全なDockerイメージを作れるようになるはずだよ！🚀

## 1. マルチステージビルドを活用しよう！🏗️
最終的なイメージサイズを小さくするために、ビルドプロセスを複数のステージに分けよう。こうすることで、最終イメージにはアプリケーションの実行に必要なファイルだけが含まれるようになるよ。ビルドステップを並行して実行できるから、効率もアップするんだ！

### 再利用可能なステージを作ろう！♻️
もし共通のコンポーネントを持つ複数のイメージがあるなら、それらをまとめた再利用可能なステージを作って、それをベースにするといいよ。Dockerは共通ステージを一度だけビルドすればいいから、メモリ効率も良くなるし、読み込みも速くなるんだ。

## 2. 適切なベースイメージを選ぼう！💡
安全なイメージを作るための最初のステップは、適切なベースイメージを選ぶことだよ。信頼できるソースからビルドされていて、できるだけ小さいイメージを選ぶのがポイント！

*   **Docker公式イメージ**: ドキュメントがしっかりしていて、ベストプラクティスを推奨していて、定期的に更新されているから、多くのアプリケーションの信頼できる出発点になるよ。
*   **Verified Publisherイメージ**: Dockerと提携している組織が公開・管理している高品質なイメージだよ。Dockerがコンテンツの信頼性を検証してくれているんだ。
*   **Docker-Sponsored Open Sourceイメージ**: Dockerがオープンソースプログラムを通じて支援しているプロジェクトが公開・管理しているイメージだよ。

これらのプログラムのバッジが付いているイメージを選ぶと安心だね！

自分でDockerfileからイメージをビルドするときは、要件に合った最小限のベースイメージを選ぼう。小さいイメージは、ポータビリティが高くてダウンロードも速いだけでなく、イメージサイズを縮小して、依存関係による脆弱性の数を最小限に抑えてくれるんだ。

ビルドと単体テスト用、そして本番用（通常はもっとスリムなイメージ）の2種類のベースイメージを使うことも検討してみてね。開発の後期段階では、コンパイラやビルドシステム、デバッグツールなどのビルドツールは必要ないことが多いから、最小限の依存関係を持つ小さなイメージは、攻撃対象領域を大幅に減らしてくれるよ。

## 3. イメージは頻繁にリビルドしよう！🔄
Dockerイメージは不変だよ。イメージをビルドするということは、その時点でのスナップショットを取るということなんだ。これには、ベースイメージ、ライブラリ、その他のソフトウェアも含まれるよ。イメージを最新の状態に保ち、安全にするために、依存関係を更新して頻繁にイメージをリビルドするようにしよう。

ビルド時に依存関係の最新バージョンを確実に取得するには、`--no-cache`オプションを使ってキャッシュヒットを避けることができるよ。

```console
$ docker build --no-cache -t my-image:my-tag .
```

ベースイメージのバージョンを固定することも検討してみてね。

## 4. `.dockerignore`で除外しよう！🗑️
ビルドに関係のないファイルをソースリポジトリを再構築せずに除外するには、`.dockerignore`ファイルを使おう。このファイルは、`.gitignore`ファイルと似た除外パターンをサポートしているよ。

例えば、`.md`拡張子を持つすべてのファイルを除外するには、次のように書くよ。

```plaintext
*.md
```

## 5. エフェメラルコンテナを作ろう！👻
Dockerfileで定義するイメージは、できるだけエフェメラル（一時的）なコンテナを生成するようにしよう。エフェメラルとは、コンテナを停止して破棄しても、最小限のセットアップと設定で再構築・置き換えができるということだよ。

ステートレスな方法でコンテナを実行する動機については、The Twelve-factor Appの「プロセス」を参照してみてね。

## 6. 不要なパッケージはインストールしない！🚫
「あったら便利かも」という理由だけで、余分なパッケージや不要なパッケージをインストールするのは避けよう。例えば、データベースイメージにテキストエディタを含める必要はないよね。

余分なパッケージや不要なパッケージをインストールしないことで、イメージの複雑さが減り、依存関係が減り、ファイルサイズが減り、ビルド時間が短縮されるんだ。

## 7. アプリケーションを分離しよう！🔗
各コンテナは1つの役割だけを持つべきだよ。アプリケーションを複数のコンテナに分離することで、水平スケーリングが容易になり、コンテナの再利用もしやすくなるんだ。例えば、Webアプリケーションスタックは、Webアプリケーション、データベース、インメモリキャッシュをそれぞれ管理するために、独自のイメージを持つ3つの独立したコンテナで構成できるよ。

各コンテナを1つのプロセスに限定するのは良い目安だけど、厳密なルールではないよ。例えば、コンテナはinitプロセスで起動できるだけでなく、一部のプログラムは独自のプロセスを起動することもあるんだ。

コンテナをできるだけクリーンでモジュール化された状態に保つために、最善の判断をしよう。コンテナが互いに依存している場合は、Dockerコンテナネットワークを使って、これらのコンテナが通信できるようにするといいよ。

## 8. 複数行の引数はソートしよう！🔠
可能であれば、複数行の引数はアルファベット順にソートして、メンテナンスを容易にしよう。これにより、パッケージの重複を避け、リストの更新がはるかに簡単になるよ。また、PRも読みやすく、レビューしやすくなるんだ。バックスラッシュ（`\`）の前にスペースを追加するのも効果的だよ。

## 9. ビルドキャッシュを活用しよう！⚡
イメージをビルドするとき、DockerはDockerfileの指示を順番に実行していくよ。各指示について、Dockerはビルドキャッシュからその指示を再利用できるかどうかを確認するんだ。

ビルドキャッシュの仕組みとキャッシュの無効化がどのように行われるかを理解することは、ビルドを高速化するために非常に重要だよ。

## 10. ベースイメージのバージョンを固定しよう！🔒
イメージタグは変更可能で、パブリッシャーはタグを更新して新しいイメージを指すことができるんだ。これは、パブリッシャーが新しいバージョンのイメージを指すようにタグを更新できるため便利だよ。そして、イメージの利用者としては、イメージをリビルドするたびに自動的に新しいバージョンを取得できるということだね。

例えば、Dockerfileで`FROM alpine:3.21`と指定すると、`3.21`は`3.21`の最新のパッチバージョンに解決されるよ。

```dockerfile
# syntax=docker/dockerfile:1
FROM alpine:3.21
```

しかし、これには欠点もあるんだ。ビルドごとに同じものが得られる保証がないんだ。これにより、破壊的な変更が発生する可能性があり、使用している正確なイメージバージョンの監査証跡も残らないことになるね。

サプライチェーンの整合性を完全に確保するには、イメージバージョンを特定のダイジェストに固定できるよ。イメージをダイジェストに固定することで、パブリッシャーがタグを新しいイメージに置き換えても、常に同じイメージバージョンを使用することが保証されるんだ。

```dockerfile
# syntax=docker/dockerfile:1
FROM alpine:3.21@sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c
```

これにより予期せぬ変更を回避できるけど、手動でイメージダイジェストを調べて含めるのは手間がかかるし、自動化されたセキュリティ修正を受けられなくなる可能性もあるよ。

Docker Scoutのデフォルトの「Up-to-Date Base Images」ポリシーは、使用しているベースイメージのバージョンが実際に最新バージョンであるかどうかをチェックしてくれるんだ。このポリシーは、Dockerfile内の固定されたダイジェストが正しいバージョンに対応しているかどうかもチェックするよ。パブリッシャーが固定したイメージを更新した場合、ポリシー評価は非準拠ステータスを返し、イメージを更新する必要があることを示してくれるんだ。

Docker Scoutは、Docker Scoutでベースイメージを自動的に更新するための自動修復ワークフローもサポートしているよ。新しいイメージダイジェストが利用可能になった場合、Docker Scoutはリポジトリにプルリクエストを自動的に作成して、Dockerfileを最新バージョンに更新できるんだ。これは、バージョンを自動的に変更するタグを使用するよりも優れているよ。なぜなら、変更がいつどのように行われたかの監査証跡があり、Junがコントロールできるからね。

## 11. CIでイメージをビルドしてテストしよう！✅
ソース管理に変更をコミットしたり、プルリクエストを作成したりするときは、GitHub Actionsやその他のCI/CDパイプラインを使って、Dockerイメージを自動的にビルドしてタグ付けし、テストするようにしよう。

## 12. Dockerfileの命令について 📝

### FROM
可能であれば、現在の公式イメージをベースにしよう。DockerはAlpineイメージを推奨しているよ。これは厳密に管理されていてサイズも小さい（現在6MB未満）のに、完全なLinuxディストリビューションだからね。

### LABEL
プロジェクトごとにイメージを整理したり、ライセンス情報を記録したり、自動化を支援したりするために、イメージにラベルを追加できるよ。各ラベルには、1つ以上のキーと値のペアを持つ`LABEL`で始まる行を追加しよう。

### RUN
長くて複雑な`RUN`ステートメントは、バックスラッシュで区切って複数行に分割すると、Dockerfileが読みやすく、理解しやすく、メンテナンスしやすくなるよ。

`apt-get`を使う場合は、常に`RUN apt-get update`と`apt-get install`を同じ`RUN`ステートメントに結合しよう。これにより、キャッシュの問題を防ぎ、常に最新のパッケージバージョンがインストールされるようになるよ。

パイプを使う場合は、`set -o pipefail &&`を先頭に追加して、パイプ内のどの段階でエラーが発生してもコマンドが失敗するようにしよう。

### CMD
`CMD`命令は、イメージに含まれるソフトウェアを引数とともに実行するために使うべきだよ。ほとんどの場合、`CMD ["executable", "param1", "param2"]`の形式で使うべきだね。

### EXPOSE
`EXPOSE`命令は、コンテナが接続をリッスンするポートを示すよ。アプリケーションの一般的なポートを使うべきだね。

### ENV
新しいソフトウェアを簡単に実行できるように、`ENV`を使ってコンテナがインストールするソフトウェアの`PATH`環境変数を更新できるよ。また、サービス固有の環境変数を提供したり、バージョン番号を管理したりするのにも便利だよ。

環境変数を完全に解除するには、`RUN`コマンドで`export`、`echo`、`unset`を1つのレイヤーで実行するようにしよう。

### ADD または COPY
`ADD`と`COPY`は機能的に似ているけど、ほとんどの場合は`COPY`を使うのがおすすめだよ。`COPY`はビルドコンテキストからコンテナにファイルをコピーするのに適しているね。

`ADD`は、ビルドの一部としてリモートのアーティファクトをダウンロードする必要がある場合に最適だよ。`wget`や`tar`のような手動でファイルを追加するよりも、より正確なビルドキャッシュを保証してくれるんだ。

### ENTRYPOINT
`ENTRYPOINT`の最適な使い方は、イメージのメインコマンドを設定することだよ。これにより、イメージがそのコマンドであるかのように実行できるようになり、`CMD`はデフォルトのフラグとして使用できるんだ。

### VOLUME
`VOLUME`命令は、データベースのストレージ領域、設定ストレージ、またはDockerコンテナによって作成されるファイルやフォルダを公開するために使うべきだよ。変更可能またはユーザーがサービス可能なイメージのあらゆる部分に`VOLUME`を使うことを強く推奨するよ。

### USER
サービスが特権なしで実行できる場合は、`USER`を使って非ルートユーザーに変更しよう。Dockerfileでユーザーとグループを作成することから始めるんだ。

`sudo`のインストールや使用は避けよう。予測できないTTYやシグナル転送の動作があり、問題を引き起こす可能性があるからね。

### WORKDIR
明確さと信頼性のために、`WORKDIR`には常に絶対パスを使うべきだよ。また、`RUN cd … && do-something`のような、読みにくく、トラブルシューティングやメンテナンスが難しい命令を増やす代わりに、`WORKDIR`を使うべきだね。

### ONBUILD
`ONBUILD`コマンドは、現在のDockerfileのビルドが完了した後に実行されるよ。`ONBUILD`は、現在のイメージから派生した子イメージで実行されるんだ。`ONBUILD`コマンドは、親Dockerfileが子Dockerfileに与える指示だと考えてみてね。

`ONBUILD`でビルドされたイメージには、別のタグを付けるべきだよ。例えば、`ruby:1.9-onbuild`や`ruby:2.0-onbuild`のようにね。

これで、Dockerのベストプラクティスはバッチリだね！何か質問はある？😊
